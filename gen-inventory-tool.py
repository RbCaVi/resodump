# convert a partially implicit/simplified json representation of a resonite object into an frdt

import itertools

def generateids():
  for i in itertools.count():
    assert i < 0x100000000 # a reasonable limit, right? 4 billion? surely
    # like i guess i could write uuids properly
    # but nobody's going to use even a million slots right?
    yield hex(0x100000000 + i)[3:] + '-0000-0000-0000-000000000000'

ids = generateids()

idmap = {}

def processobject1(o):
  # defaults and ids
  # an object has a defined set of properties
  # name is required
  # tag = null, active = true
  # children = [], components = []
  # position = [0, 0, 0], rotation = [0, 0, 0, 1], scale = [1, 1, 1]
  # orderoffset = 0
  # id, persistent-id, and parentreference are autogenerated
  assert 'Name' in o
  if 'Tag' not in o:
    o['Tag'] = None
  if 'Active' not in o:
    o['Active'] = True
  if 'Children' not in o:
    o['Children'] = []
  if 'Components' not in o:
    o['Components'] = []
  if 'Position' not in o:
    o['Position'] = [0, 0, 0]
  if 'Rotation' not in o:
    o['Rotation'] = [0, 0, 0, 1]
  if 'Scale' not in o:
    o['Scale'] = [1, 1, 1]
  o['OrderOffset'] = 0
  o['ID'] = '###id###'
  o['Persistent-ID'] = '###id###'
  o['ParentReference'] = '###id###'
  out = {}
  for prop,value in o.items():
    if value == '###id###': # no sane person will put this as a string value right?
      out[prop] = next(ids)
      continue
    if prop == 'id':
      continue
    if prop == 'Children':
      out['Children'] = [processobject1(c) for c in value]
      continue
    if prop == 'Components':
      out['Components'] = [processcomponent1(c) for c in value]
      continue
    else:
      value = processvalue1(value)
    if type(value) != dict or 'ID' not in value:
      value = {"ID": next(ids), "Data": value}
    out[prop] = value
  if 'id' in o:
    idmap[o['id']] = out['ID']
  return out

types = []

def processcomponent1(c):
  # defaults and ids
  # a component has some default properties
  # and others as well
  # type is required
  # enabled = true
  # updateorder = 0
  # id and persistent-id are autogenerated
  assert 'type' in c
  if c['type'] not in types:
    types.append(c['type'])
  c['type'] = types.index(c['type'])
  if 'Enabled' not in c:
    c['Enabled'] = True
  if 'UpdateOrder' not in c:
    c['UpdateOrder'] = 0
  c['ID'] = '###id###'
  c['persistent-ID'] = '###id###'
  out = {}
  for prop,value in c.items():
    if value == '###id###': # no sane person will put this as a string value right?
      out[prop] = next(ids)
      continue
    if prop == 'id':
      continue
    if prop == 'type':
      out['type'] = value
      continue
    value = processvalue1(value)
    if type(value) != dict or 'ID' not in value:
      value = {"ID": next(ids), "Data": value}
    out[prop] = value
  if 'id' in c:
    idmap[c['id']] = out['ID']
  return out

def processasset1(a):
  # defaults and ids
  # an asset has some default properties
  # and others as well
  # type is required
  # enabled = true
  # updateorder = 0
  # persistent = false
  # id is autogenerated
  assert 'type' in a
  if a['type'] not in types:
    types.append(a['type'])
  a['type'] = types.index(a['type'])
  if 'Enabled' not in a:
    a['Enabled'] = True
  if 'UpdateOrder' not in a:
    a['UpdateOrder'] = 0
  if 'persistent' not in a:
    a['persistent'] = False
  a['ID'] = '###id###'
  out = {}
  for prop,value in a.items():
    if value == '###id###': # no sane person will put this as a string value right?
      out[prop] = next(ids)
      continue
    if prop == 'id':
      continue
    if prop == 'type':
      out['type'] = value
      continue
    value = processvalue1(value)
    if type(value) != dict or 'ID' not in value:
      value = {"ID": next(ids), "Data": value}
    out[prop] = value
  if 'id' in a:
    idmap[a['id']] = out['ID']
  return out

def processvalue1(v):
  # values are more flexible than objects and components
  # they don't always have an id key tbh
  if type(v) == dict:
    if 'id' in v and 'ID' not in v:
      v['ID'] = '###id###'
    out = {}
    for prop,value in v.items():
      if value == '###id###': # no sane person will put this as a string value right?
        out[prop] = next(ids)
        continue
      if prop == 'id':
        continue
      value = processvalue1(value)
      out[prop] = value
    if 'id' in v:
      idmap[v['id']] = out['ID']
    return out
  elif type(v) == list:
    return [processvalue1(sv) for sv in v]
  else:
    return v

def processobject2(o):
  # resolve id references and restructure
  # objects actually don't have any id references
  o['Children'] = [processobject2(c) for c in o['Children']]
  o['Components'] = {'ID': next(ids), 'Data': [processcomponent2(c) for c in o['Components']]}
  return o

def processcomponent2(c):
  # resolve id references and restructure
  for prop,value in c.items():
    if prop == 'type':
      continue
    c[prop] = processvalue2(c[prop])
  t = c['type']
  del c['type']
  return {'Type': t, 'Data': c}
  
processasset2 = processcomponent2

assethashes = {}

def processvalue2(v):
  # resolve id references
  if type(v) == dict:
    return {k: processvalue2(sv) for k,sv in v.items()}
  if type(v) == list:
    return [processvalue2(sv) for sv in v]
  if type(v) == str:
    if v.startswith('###') and v.endswith('###'):
      return idmap[v[3:-3]]
    if v.startswith('##@') and v.endswith('###'):
      assethashes[v[3:-3]] = hex(0x20000000000000000 +hash(v[3:-3]))[3:] * 4
      return '@packdb:///' + assethashes[v[3:-3]]
  return v

import pfmain

def addprotoflux(o):
  # adds protoflux children to any slot with a 'source' key
  if 'source' in o:
    with open(o['source']) as f:
      s = f.read()
    o['Children'] = pfmain.generate(s)
    del o['source']
  else:
    if 'Children' in o:
      for c in o['Children']:
        addprotoflux(c)

import json

with open('inventory-tool-data.json', 'r') as f:
  tree = json.load(f)

addprotoflux(tree['Object'])

o = processobject1(tree['Object'])
assets = [processasset1(a) for a in tree['Assets']]

print(idmap)

o = processobject2(o)
assets = [processasset2(a) for a in assets]

import pprint

out = {
  "VersionNumber": "2025.5.23.1096",
  "FeatureFlags": {
    "ColorManagement": 0,
    "ResetGUID": 0,
    "ProtoFlux": 0,
    "TEXTURE_QUALITY": 0,
    "TypeManagement": 0,
    "ALIGNER_FILTERING": 0,
    "PhotonDust": 0,
    "Awwdio": 0
  },
  "TypeVersions": {
    # what do i put here
    # can i use some kind of.... reflection?
  }
}

out['Types'] = types
out['Assets'] = assets
out['Object'] = o

import frdt

#with open('out.frdt', 'wb') as f:
#  f.write(frdt.write(out))

import resonitepackage
import datetime

now = datetime.datetime.now(datetime.timezone.utc).isoformat()[:-6] + 'Z' # snip off the +00:00 at the end to match the format from resonite
me = 'U-1YuDa214TQG'

mainrecord = {
  'creationTime': now,
  'description': None,
  'firstPublishTime': None,
  'id': 'R-Main',
  'isDeleted': False,
  'isForPatrons': False,
  'isListed': False,
  'isPublic': False,
  'isReadOnly': False,
  'lastModificationTime': now,
  'migrationMetadata': None,
  'name': out['Object']['Name']['Data'],
  'ownerId': me,
  'ownerName': None,
  'path': None,
  'randomOrder': 0,
  'rating': 0,
  'recordType': 'object',
  'submissions': None,
  'tags': None,
  'thumbnailUri': None,
  'version': {
    'globalVersion': 0,
    'lastModifyingMachineId': None,
    'lastModifyingUserId': None,
    'localVersion': 0
  },
  'visits': 0
}

assetmanifest = []

import meshx

with open('out/invside.meshx', 'wb') as f:
  mesh = {
    'vertices': [
      (-0.1, -0.1, -0.1),
      (-0.3, -0.1, -0.1),
      (-0.1,  0.1, -0.1),
      (-0.3,  0.1, -0.1),
      (-0.1, -0.1,  0.1),
      (-0.3, -0.1,  0.1),
      (-0.1,  0.1,  0.1),
      (-0.3,  0.1,  0.1),
    ],
    'meshes': [[
      (0, 1, 3),
      (0, 2, 3),
      (4, 5, 7),
      (4, 6, 7),
      (0, 1, 5),
      (0, 4, 5),
      (2, 3, 7),
      (2, 6, 7),
      (0, 2, 6),
      (0, 4, 6),
      (1, 3, 7),
      (1, 5, 7),
    ]],
  }
  f.write(meshx.write(mesh))

with open('out/slot.meshx', 'wb') as f:
  mesh = {
    'vertices': [
      (-0.125, -0.125, -0.125),
      ( 0.125, -0.125, -0.125),
      (-0.125,  0.125, -0.125),
      ( 0.125,  0.125, -0.125),
      (-0.125, -0.125,  0.125),
      ( 0.125, -0.125,  0.125),
      (-0.125,  0.125,  0.125),
      ( 0.125,  0.125,  0.125),
    ],
    'meshes': [[
      (0, 1, 3),
      (0, 2, 3),
      (4, 5, 7),
      (4, 6, 7),
      (0, 1, 5),
      (0, 4, 5),
      (2, 3, 7),
      (2, 6, 7),
      (0, 2, 6),
      (0, 4, 6),
      (1, 3, 7),
      (1, 5, 7),
    ]],
  }
  f.write(meshx.write(mesh))

with open('out/tool.meshx', 'wb') as f:
  mesh = {
    'vertices': [
      (-0.125, -0.125, -0.125),
      ( 0.125, -0.125, -0.125),
      (-0.125,  0.125, -0.125),
      ( 0.125,  0.125, -0.125),
      (-0.125, -0.125,  0.125),
      ( 0.125, -0.125,  0.125),
      (-0.125,  0.125,  0.125),
      ( 0.125,  0.125,  0.125),
    ],
    'meshes': [[
      (0, 1, 3),
      (0, 2, 3),
      (4, 5, 7),
      (4, 6, 7),
      (0, 1, 5),
      (0, 4, 5),
      (2, 3, 7),
      (2, 6, 7),
      (0, 2, 6),
      (0, 4, 6),
      (1, 3, 7),
      (1, 5, 7),
    ]],
  }
  f.write(meshx.write(mesh))

with resonitepackage.ResonitePackage('out/inventory-tool.resonitepackage', 'w') as package:
  for a,h in assethashes.items():
    with open(a, 'rb') as f:
      data = f.read()
      package.addasset(h, data)
      assetmanifest.append({'hash': h, 'bytes': len(data)})
  maindata = frdt.write(out)
  mainhash = hex(0x20000000000000000 +hash(maindata))[3:] * 4
  package.addasset(mainhash, maindata)
  mainrecord['assetManifest'] = assetmanifest
  mainrecord['assetUri'] = 'packdb:///' + mainhash
  package.setmainrecord(mainrecord)